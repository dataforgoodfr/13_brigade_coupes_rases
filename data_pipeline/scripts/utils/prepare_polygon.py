# Custom code derived from Yoann Crouin's written code.
# link --> https://github.com/dataforgoodfr/13_brigade_coupes_rases/blob/main/analytics/notebooks/prepare_sufosat_v3_layer.py
# # -*- coding: utf-8 -*-
import pandas as pd
from tqdm import tqdm
import geopandas as gpd
from utils.logging_etl import etl_logger
from utils.disjoin_set import DisjointSet


class PreparePolygon:
    def __init__(self):
        self.logger = etl_logger("logs/transform.log")
        self.disjoin_set = DisjointSet

    def parse_sufosat_date(self, sufosat_date: float) -> pd.Timestamp:
        """
        Converts SUFOSAT date format to a pandas Timestamp.

        The input format is YYDDD, where YY is the year (e.g., 18-25 = 2018-2025)
        and DDD is the day of the year (1-366).

        Parameters
        ----------
        sufosat_date : float
            Date in SUFOSAT format (YYDDD).

        Returns
        -------
        pd.Timestamp
            Converted date as a pandas Timestamp.

        Examples
        --------
        ->>> parse_sufosat_date(19032)
        Timestamp('2019-02-01 00:00:00')  # February 1, 2019 (32nd day of 2019)
        """

        sufosat_date = int(sufosat_date)
        return pd.Timestamp(year=2000 + sufosat_date // 1000, month=1, day=1) + pd.Timedelta(
            days=(sufosat_date % 1000) - 1
        )

    def pair_clear_cuts_through_space_and_time(
        self,
        gdf: gpd.GeoDataFrame,
        max_meters_between_clear_cuts: int,
        max_days_between_clear_cuts: int,
    ) -> pd.DataFrame:
        """
        Identifies pairs of clear-cuts that are within a specified distance and a
        specified number of days of each other.

        Parameters
        ----------
        gdf : gpd.GeoDataFrame
            GeoDataFrame containing clear-cut polygons with a 'geometry' column.
        max_meters_between_clear_cuts : int
            Maximum distance in meters that can separate two clear-cuts for them
            to be considered a pair.
        max_days_between_clear_cuts : int
            Maximum time difference in days between clear-cuts to consider them related.


        Returns
        -------
        pd.DataFrame
            DataFrame with columns:
            - index_left: Index of the first clear-cut in each pair
            - date_left: Date of the first clear-cut
            - index_right: Index of the second clear-cut in each pair
            - date_right: Date of the second clear-cut

        Notes
        -----
        This function can consume a significant amount of memory due to the Cartesian product
        generated by the spatial join.
        """
        self.logger.info(
            f"Pairing clear-cuts within {max_meters_between_clear_cuts} meters "
            f"and {max_days_between_clear_cuts} days of each other"
        )

        # Cluster the clear-cuts that are within `max_meters_between_clear_cuts` of each other
        # Lambert-93 CRS uses meters as its unit of measurement for distance.
        def batch_sjoin(gdf, batch_size=100, distance=max_meters_between_clear_cuts):
            """
            Performs a batched spatial join to find clear-cuts within a specified distance.

            This function divides the input GeoDataFrame into smaller batches to reduce memory usage
            and performs a spatial join for each batch to find clear-cuts within the given distance.

            Parameters
            ----------
            gdf : gpd.GeoDataFrame
                GeoDataFrame containing clear-cut polygons with a 'geometry' column.
            batch_size : int, optional
                Number of rows to process in each batch (default is 100).
            distance : int
                Maximum distance in meters to consider two clear-cuts as neighbors.

            Returns
            -------
            pd.DataFrame
                DataFrame containing the results of the spatial join, with columns:
                - index_left: Index of the clear-cut in the batch.
                - index_right: Index of the neighboring clear-cut.
            """
            results = []
            total_batches = len(gdf) // batch_size + (1 if len(gdf) % batch_size > 0 else 0)

            for i in tqdm(range(0, len(gdf), batch_size), total=total_batches):
                batch = gdf.iloc[i : i + batch_size]
                batch_join = batch.sjoin(
                    gdf, how="left", predicate="dwithin", distance=distance
                )
                results.append(batch_join)

            return pd.concat(results).reset_index().rename(columns={"index": "index_left"})

        clear_cut_pairs = batch_sjoin(gdf, batch_size=100)

        # Ignore clear-cuts that intersect with themselves
        clear_cut_pairs = clear_cut_pairs[
            clear_cut_pairs["index_left"] != clear_cut_pairs["index_right"]
        ]

        # Remove duplicates (left -> right exists, ignore right -> left)
        clear_cut_pairs = clear_cut_pairs[
            clear_cut_pairs["index_left"] < clear_cut_pairs["index_right"]
        ]

        # Remove pairs if the date difference is too big
        clear_cut_pairs = clear_cut_pairs[
            (clear_cut_pairs["date_left"] - clear_cut_pairs["date_right"]).dt.days.abs()
            <= max_days_between_clear_cuts
        ]

        self.logger.info(
            f"Found {len(clear_cut_pairs)} potential clear-cut pairs (before shape complexity filtering)"
        )

        return clear_cut_pairs

    def regroup_clear_cut_pairs(self, clear_cut_pairs: pd.DataFrame) -> list[set[int]]:
        """
        Groups connected clear-cut pairs into distinct sets (clusters).

        Given a set of identified clear-cut pairs, this function groups all
        interconnected clear cuts into the same set using a disjoint-set
        data structure (also known as a union-find algorithm).

        Parameters
        ----------
        clear_cut_pairs : pd.DataFrame
            DataFrame containing pairs of clear-cut IDs that are connected,
            with columns 'index_left' and 'index_right'.

        Returns
        -------
        list[set[int]]
            A list of sets, where each set contains the IDs of clear cuts
            belonging to the same cluster.

        Examples
        --------
        If we have four clear cuts (A, B, C, and D) and the identified pairs
        are (A, B) and (B, D), the function will group them as:
        - Group 1: {A, B, D}
        - Group 2: {C}
        """
        self.logger.info("Grouping connected clear-cuts into clusters")

        # Get all unique clear-cut indices from both columns
        all_indices = pd.concat(
            [clear_cut_pairs["index_left"], clear_cut_pairs["index_right"]]
        ).unique()

        # Start with each clear cut having its own group
        clear_cuts_disjoint_set = self.disjoin_set(all_indices)

        # Group the clear cuts that belong together one pair at a time
        for index_left, index_right in tqdm(
            clear_cut_pairs[["index_left", "index_right"]].itertuples(index=False),
            total=len(clear_cut_pairs),
            desc="Merging connected clear-cuts",
        ):
            clear_cuts_disjoint_set.merge(index_left, index_right)

        # Get the resulting subsets (clusters)
        subsets = clear_cuts_disjoint_set.subsets()

        self.logger.info(f"Created {len(subsets)} clear-cut clusters")

        return subsets

    def cluster_clear_cuts(
        self,
        gdf: gpd.GeoDataFrame,
        max_meters_between_clear_cuts: int,
        max_days_between_clear_cuts: int,
    ) -> gpd.GeoDataFrame:
        """
        Clusters individual clear-cuts based on spatial and temporal proximity.
        Parameters
        ----------
        gdf : gpd.GeoDataFrame
            GeoDataFrame containing clear-cut polygons with 'date' and 'geometry' columns.
        max_meters_between_clear_cuts : int
            Maximum distance in meters between clear-cuts to consider them related.
        max_days_between_clear_cuts : int
            Maximum time difference in days between clear-cuts to consider them related.

        Returns
        -------
        gpd.GeoDataFrame
            The input GeoDataFrame with an additional 'clear_cut_group' column
            that assigns each polygon to a cluster.

        Notes
        -----
        The function modifies the input GeoDataFrame by adding a 'clear_cut_group' column.
        """
        self.logger.info("Clustering clear-cuts by spatial and temporal proximity")

        # Identify the clear cut groups
        clear_cut_pairs = self.pair_clear_cuts_through_space_and_time(
            gdf, max_meters_between_clear_cuts, max_days_between_clear_cuts
        )
        clear_cut_groups = self.regroup_clear_cut_pairs(clear_cut_pairs)

        # Assign a clear cut group id to each clear cut polygon
        self.logger.info("Assigning cluster IDs to clear-cuts")
        for i, subset in tqdm(
            enumerate(clear_cut_groups),
            total=len(clear_cut_groups),
            desc="Assigning cluster IDs",
        ):
            gdf.loc[list(subset), "clear_cut_group"] = i

        self.logger.info(
            f"Clustering complete: {gdf['clear_cut_group'].nunique()} total clusters"
        )

        return gdf

    def union_clear_cut_clusters(self, gdf: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
        """
        Combines clear-cuts belonging to the same cluster into single geometries.

        This function dissolves the geometries based on the 'clear_cut_group' column,
        and calculates aggregate statistics for each cluster.

        Parameters
        ----------
        gdf : gpd.GeoDataFrame
            GeoDataFrame with 'clear_cut_group', 'date', and 'geometry' columns.

        Returns
        -------
        gpd.GeoDataFrame
            A new GeoDataFrame with one row per cluster, containing:
            - Unified geometry
            - Minimum and maximum dates
            - Time span of the cluster in days
            - Number of clear-cuts in each cluster
        """
        self.logger.info("Merging clear-cuts within each cluster")

        # Calculate group sizes before dissolve
        clear_cut_group_size = gdf.groupby("clear_cut_group").size()

        self.logger.info("Performing spatial union of geometries within each cluster")
        gdf = gdf.dissolve(by="clear_cut_group", aggfunc={"date": ["min", "max"]}).rename(
            columns={
                ("date", "min"): "date_min",
                ("date", "max"): "date_max",
            }
        )
        gdf["days_delta"] = (gdf["date_max"] - gdf["date_min"]).dt.days
        gdf["clear_cut_group_size"] = clear_cut_group_size

        # Fill tiny gaps left after the dissolve/union operation
        self.logger.info("Filling tiny gaps in the dissolved geometries")
        gdf["geometry"] = gdf["geometry"].buffer(0.0001)

        self.logger.info(f"Successfully created {len(gdf)} merged clear-cut clusters")

        return gdf
